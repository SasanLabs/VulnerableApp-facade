import React from "react";
import { render, screen, waitFor } from "@testing-library/react";

import { Content } from "../Components/Content";
import testFixture from "./fixtures";

describe("JwtVulnerability content", () => {
  const vulnerabilityLevels = [
    "LEVEL_1",
    "LEVEL_2",
    "LEVEL_3",
    "LEVEL_4",
    "LEVEL_5",
    "LEVEL_6",
    "LEVEL_7",
    "LEVEL_8",
    "LEVEL_9",
    "LEVEL_10",
  ];

  it("should render correctly", () => {
    const mock = () => jest.fn();
    const state = {
      ...testFixture,
      activeApplication: "VulnerableApp",
      activeVulnerability: "JWTVulnerability",
      activeLevel: "LEVEL_1",
    };
    const { container } = render(
      <Content globalState={state} setGlobalState={mock} />
    );

    expect(container).toMatchSnapshot();
  });

  it.each(vulnerabilityLevels)(
    `%s should render vulnerability description`,
    async (level) => {
      const mock = () => jest.fn();
      const state = {
        ...testFixture,
        activeApplication: "VulnerableApp",
        activeVulnerability: "JWTVulnerability",
        activeLevel: level,
      };
      const { rerender } = render(
        <Content globalState={testFixture} setGlobalState={mock} />
      );

      rerender(<Content globalState={state} setGlobalState={mock} />);

      const header = screen.getByText("Vulnerability Description");
      expect(header).toBeInTheDocument();

      await waitFor(() => {
        const description = screen.getByTestId(
          "VULNERABILITY_CONTENT_DESCRIPTION"
        );
        const link1 = screen.getByText("Wiki Link");
        const link2 = screen.getByText("Jwt.io");
        const link3 = screen.getByText(
          "JSON Web Token Best Current Practices(ieft document)"
        );
        const link4 = screen.getByText(
          "OWASP cheatsheet for vulnerabilities in JWT implementation"
        );
        const link5 = screen.getByText(
          "For server side vulnerabilities in JWT implementations"
        );

        expect(description).toHaveTextContent(
          "JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed.There can be multiple things that can go wrong with the implementation of JWT and that can impact the Authentication or Authorization of the application and result in complete compromise of the system."
        );
        expect(link1).toBeInTheDocument();
        expect(link1).toHaveAttribute(
          "href",
          "https://en.wikipedia.org/wiki/JSON_Web_Token"
        );
        expect(link2).toBeInTheDocument();
        expect(link2).toHaveAttribute("href", "https://jwt.io/introduction/");
        expect(link3).toBeInTheDocument();
        expect(link3).toHaveAttribute(
          "href",
          "https://tools.ietf.org/html/draft-ietf-oauth-jwt-bcp-06"
        );
        expect(link4).toBeInTheDocument();
        expect(link4).toHaveAttribute(
          "href",
          "https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_Cheat_Sheet_for_Java.html"
        );
        expect(link5).toBeInTheDocument();
        expect(link5).toHaveAttribute(
          "href",
          "https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries"
        );
      });
    }
  );

  it.each(vulnerabilityLevels)(
    `%s should render practice vulnerability section`,
    async (level) => {
      const mock = () => jest.fn();
      const state = {
        ...testFixture,
        activeApplication: "VulnerableApp",
        activeVulnerability: "JWTVulnerability",
        activeLevel: level,
      };
      const { rerender } = render(
        <Content globalState={testFixture} setGlobalState={mock} />
      );

      rerender(<Content globalState={state} setGlobalState={mock} />);

      const header = screen.getByText("Practice Vulnerability");
      expect(header).toBeInTheDocument();
    }
  );

  const input = [
    [
      "LEVEL_1",
      "The request contains JWT token which is leaked in the URL. This can violate PCI and most organizational compliance policies.",
    ],
    [
      "LEVEL_2",
      "Cookie based JWT token but without Secure/HttpOnly flags and also without cookie prefixes.",
    ],
    [
      "LEVEL_3",
      "Cookie based JWT token but with HttpOnly flag but without Secure flag and also without cookie prefixes.",
    ],
    [
      "LEVEL_4",
      "Cookie based JWT token but with HttpOnly flag but without Secure flag and also without cookie prefixes.",
    ],
    ["LEVEL_4", "Cookie based JWT token signed using Weak key vulnerability."],
    [
      "LEVEL_5",
      "Cookie based JWT token but with HttpOnly flag but without Secure flag and also without cookie prefixes.",
    ],
    ["LEVEL_5", "Cookie based Null byte vulnerable JWT token validator."],
  ];

  it.each(input)(`%s should render hints`, async (level, hint) => {
    const mock = () => jest.fn();
    const state = {
      ...testFixture,
      activeApplication: "VulnerableApp",
      activeVulnerability: "JWTVulnerability",
      activeLevel: level,
      showHints: true,
    };
    const { rerender } = render(
      <Content globalState={testFixture} setGlobalState={mock} />
    );

    rerender(<Content globalState={state} setGlobalState={mock} />);

    await waitFor(() => {
      const header = screen.getByTestId("VULNERABILITY_HINTS");

      expect(header).toBeInTheDocument();
      expect(header).toHaveTextContent(hint);
    });
  });
});
